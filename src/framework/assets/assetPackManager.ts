import { AssetPack, AssetPackState } from "./assetPack";
import { Signal, Loader, Game } from "phaser-ce";
import { Entry } from "../../entry";
import { Assert } from "../tools/assert";

type LoadingTaskDef = { pack:string, handle: LoadingTaskHandle }  
type NotifyTask = { packs:string[], fn:Function }
export class AssetPackManager {
    
    private static conf:Object;    
    private static queue:LoadingTaskDef[];
    private static notifyTasks:NotifyTask[];
    static packs:Object;
    static runningTask:LoadingTask;
    static onPackLoad:Signal;

    static init() {        
        let json = Entry.game.cache.getJSON("manifest");     
        this.queue = [];        
        this.notifyTasks = [];
        this.onPackLoad = new Signal();
        this.onPackLoad.add( () => {
            this.runningTask = null;
            this.processQueue();
            this.updateNotifyTasks();
        });
        AssetPackManager.conf = json;
        AssetPackManager.packs = {};
        for( var packName in json ) {
            AssetPackManager.packs[packName] = new AssetPack(json[packName], packName);
        }

        (<any>window).isr = this.isReady;
    }

    static isReady( packList:string[] ):boolean {        
        for (var i = 0; i < packList.length; i++) {
            var packName = packList[i];
            var pack = AssetPackManager.packs[packName];
            Assert.that( pack, `No asset pack with named ${packName}` );
            if( pack.state !== AssetPackState.READY )
                return false;
        }
        return true;
    }
  
    static addToQueue( name:string ) : LoadingTaskHandle {     
        Assert.that( this.packs[name], `No pack with name = ${name}`)
        Assert.that( this.packs[name].state !== AssetPackState.READY, `Pack ${name} is ready`);
        if( this.runningTask && this.runningTask.def.pack == name) {
            // already loading this pack
            return this.runningTask.def.handle;
        } else {
            // if pack is already in the queue -- return its handle
            for( var i in this.queue ) {
                if( this.queue[i].pack == name )
                    return this.queue[i].handle;
            }
            // pack is not in queue -- create new entry
            var handle = new LoadingTaskHandle( name );
            this.queue.push({
                pack: name,
                handle: handle
            });
            this.processQueue();
            return handle;
        }
    }

    static prioritize( name:string ) {
        Assert.that( this.packs[name], "No pack with name = " + name)
        // do nothing if already loading this pack
        if( this.runningTask.def.pack == name) return;
        
        // trying to find existing definition and put it in beginning of the queue
        for( let i in this.queue ) {
            var def = this.queue[i];
            if( def.pack == name ) {
                let t = this.queue[0];
                this.queue[0] = def;
                this.queue[i] = t;
                return;
            }
        }
        
        // pack was not found 
        if( DEBUG )
            console.warn(`Pack ${name} was not prioritized (not in queue)`)
        return;
    }

    static callWhenReady( packs:string[], fn:Function ) {
        if( AssetPackManager.isReady(packs) ) {
            fn();
        } else {
            this.notifyTasks.push({
                fn: fn,
                packs: packs
            });
        }
    }

    private static updateNotifyTasks() {
        let i = this.notifyTasks.length;
        while( i-- ) {
            if( this.isReady( this.notifyTasks[i].packs ) ) {
                this.notifyTasks[i].fn();
                this.notifyTasks.splice(i,1);
            }
        }
    }

    private static processQueue() {
        if( this.runningTask || this.queue.length == 0 ) return;
                
        let def = this.queue.shift(); 
        let task = new LoadingTask( def );               
        AssetPackManager.packs[def.pack].state = AssetPackState.LOADING;
        task.start(); 
        this.runningTask = task;
    }

}


class LoadingTaskHandle {
    readonly onProgressChange:Signal;
    readonly onComplete:Signal;

    constructor( public pack:string ){
        this.onComplete = new Signal();
        this.onProgressChange = new Signal();
    }

    dispose() {
        this.onProgressChange.dispose();
        this.onComplete.dispose();
        this.pack = null;
    }
}

class LoadingTask {
    private loading:boolean = false;
    private loader:Loader;

    constructor( public def:LoadingTaskDef ) {        
        this.loader = new Loader( Entry.game );             
        this.addPack(def.pack);
    }

    private addPack( name:string ) {        
        if( this.loading ) return;  

        let pack = AssetPackManager.packs[name];

        if( pack.entries["image"] )
            for( var imageName in pack.entries["image"] ) {
                var entry = pack.entries["image"][imageName];
                this.loader.image( (<string>entry.name).replace(/\\/g, '/'), entry.url );
            }
        
        if( pack.entries["audio"] )
            for( var name in pack.entries["audio"] ) {
                entry = pack.entries["audio"][name];
                this.loader.audio((<string>entry.name).replace(/\\/g, '/'), entry.url );
            }

        if( pack.entries["json"] )
            for( name in pack.entries["json"] ) {
                entry = pack.entries["json"][name];
                this.loader.json((<string>entry.name).replace(/\\/g, '/'), entry.url );
            }

        if( pack.entries["raw"] )
            for( name in pack.entries["raw"] ) {
                entry = pack.entries["raw"][name];
                this.loader.text((<string>entry.name).replace(/\\/g, '/'), entry.url );
            }

        if( pack.entries["font"] )
            for( name in pack.entries["font"] ) {
                entry = pack.entries["font"][name];
                this.loader.bitmapFont((<string>entry.name).replace(/\\/g, '/'), entry.image, entry.url );
            }

        if( pack.entries["spritesheet"] )
            for( name in pack.entries["spritesheet"] ) {
                entry = pack.entries["spritesheet"][name];
                this.loader.atlasJSONHash((<string>entry.name).replace(/\\/g, '/'), entry.image, entry.url );
            }

        return this;
    }   

    start() {
        if( this.loading ) return;

        this.loading = true;
        this.loader.onLoadComplete.addOnce( this.complete, this );
        this.loader.onFileComplete.add(() => this.def.handle.onProgressChange.dispatch(this.loader.progress/100), this);
        this.loader.start();
        return this;
    }

    dispose() {
        this.def.handle.dispose();
    }

    private complete() {
        AssetPackManager.packs[this.def.pack].state = AssetPackState.READY;
        AssetPackManager.onPackLoad.dispatch( name );
        this.def.handle.onComplete.dispatch();
        this.dispose();
        return this;
    }
}